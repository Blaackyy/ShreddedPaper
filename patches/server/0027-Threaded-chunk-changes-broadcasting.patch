From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 30 May 2024 20:37:51 +0900
Subject: [PATCH] Threaded chunk changes broadcasting


diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
index 9c9fa516d451d67d8ed6c1721766572ed43c8a9e..e9d97c6941cc4c31f2dd2c494614b2549c867a4b 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -5,6 +5,7 @@ import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Mob;
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChangesBroadcaster.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChangesBroadcaster.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2bb0a1bb5c67340261764c0751d37801c23a824
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChangesBroadcaster.java
@@ -0,0 +1,66 @@
+package io.multipaper.shreddedpaper.threading;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import net.minecraft.server.level.ChunkHolder;
+import org.slf4j.Logger;
+
+public class ShreddedPaperChangesBroadcaster {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    private static final ThreadLocal<ReferenceOpenHashSet<ChunkHolder>> needsChangeBroadcastingThreadLocal = new ThreadLocal<>();
+    private static final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcastingMainThread = new ReferenceOpenHashSet<>();
+
+    public static void setAsWorkerThread() {
+        if (needsChangeBroadcastingThreadLocal.get() == null) {
+            needsChangeBroadcastingThreadLocal.set(new ReferenceOpenHashSet<>());
+        }
+    }
+
+    public static void add(ChunkHolder chunkHolder) {
+        ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = needsChangeBroadcastingThreadLocal.get();
+        if (needsChangeBroadcasting != null) {
+            needsChangeBroadcasting.add(chunkHolder);
+        } else {
+            LOGGER.warn("Adding chunk holder to main thread!", new Exception());
+            synchronized (needsChangeBroadcastingMainThread) {
+                needsChangeBroadcastingMainThread.add(chunkHolder);
+            }
+        }
+    }
+
+    public static void remove(ChunkHolder chunkHolder) {
+        ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = needsChangeBroadcastingThreadLocal.get();
+        if (needsChangeBroadcasting == null || !needsChangeBroadcasting.remove(chunkHolder)) {
+            LOGGER.warn("Removing chunk holder from main thread!", new Exception());
+            synchronized (needsChangeBroadcastingMainThread) {
+                needsChangeBroadcastingMainThread.remove(chunkHolder);
+            }
+        }
+    }
+
+    public static void broadcastChanges() {
+        broadcastChanges(needsChangeBroadcastingThreadLocal.get());
+    }
+
+    public static void broadcastChangesMainThread() {
+        synchronized (needsChangeBroadcastingMainThread) {
+            broadcastChanges(needsChangeBroadcastingMainThread);
+        }
+    }
+
+    public static void broadcastChanges(ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting) {
+        if (!needsChangeBroadcasting.isEmpty()) {
+            ReferenceOpenHashSet<ChunkHolder> copy = needsChangeBroadcasting.clone();
+            needsChangeBroadcasting.clear();
+            for (ChunkHolder holder : copy) {
+                holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
+                if (holder.needsBroadcastChanges()) {
+                    // I DON'T want to KNOW what DUMB plugins might be doing.
+                    needsChangeBroadcasting.add(holder);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
index 6c684c701cdae2c87a553fdf01291800d5918279..b977d3af17d42bdd9f859e962c894bfde102c245 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
@@ -51,6 +51,8 @@ public class ShreddedPaperChunkTicker {
             throw new IllegalStateException("Ticking region " + level.convertable.getLevelId() + " " + region.getRegionPos() + " outside of ShreddedPaperTickThread!");
         }
 
+        ShreddedPaperChangesBroadcaster.setAsWorkerThread();
+
         while (region.getInternalTaskQueue().executeTask());
 
         level.chunkTaskScheduler.chunkHolderManager.processUnloads(region);
@@ -67,6 +69,8 @@ public class ShreddedPaperChunkTicker {
 
         while (region.getInternalTaskQueue().executeTask());
 
+        ShreddedPaperChangesBroadcaster.broadcastChanges();
+
         if (region.isEmpty()) {
             level.chunkSource.tickingRegions.remove(region.getRegionPos());
         }
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 472b9494f8a34a8ba90d6a2936b0db7530a229ad..2062ce1a711f76f989cb5efd288d901a1eac8de2 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -1,6 +1,7 @@
 package net.minecraft.server.level;
 
 import com.mojang.datafixers.util.Pair;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChangesBroadcaster;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.ArrayList;
@@ -79,7 +80,7 @@ public class ChunkHolder {
     public void onChunkAdd() {
         // Paper start - optimise chunk tick iteration
         if (this.needsBroadcastChanges()) {
-            this.chunkMap.needsChangeBroadcasting.add(this);
+            ShreddedPaperChangesBroadcaster.add(this); // this.chunkMap.needsChangeBroadcasting.add(this); // ShreddedPaper - handled by the regions
         }
         // Paper end - optimise chunk tick iteration
     }
@@ -87,7 +88,7 @@ public class ChunkHolder {
     public void onChunkRemove() {
         // Paper start - optimise chunk tick iteration
         if (this.needsBroadcastChanges()) {
-            this.chunkMap.needsChangeBroadcasting.remove(this);
+            ShreddedPaperChangesBroadcaster.remove(this); // this.chunkMap.needsChangeBroadcasting.remove(this); // ShreddedPaper - handled by the regions
         }
         // Paper end - optimise chunk tick iteration
     }
@@ -270,7 +271,7 @@ public class ChunkHolder {
 
     private void addToBroadcastMap() {
         io.papermc.paper.util.TickThread.ensureTickThread(this.chunkMap.level, this.pos, "Asynchronous ChunkHolder update is not allowed");
-        this.chunkMap.needsChangeBroadcasting.add(this);
+        ShreddedPaperChangesBroadcaster.add(this); // this.chunkMap.needsChangeBroadcasting.add(this); // ShreddedPaper - handled by the regions
     }
     // Paper end - optimise chunk tick iteration
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index e8d9cb71daf8047117097c201a6dc6c683a8b8a1..915879030562cdb34a06cc71df1ae06c7b5cf0c8 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -246,7 +246,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final io.papermc.paper.util.player.NearbyPlayers nearbyPlayers;
     // Paper end
     // Paper start - optimise chunk tick iteration
-    public final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
+    // public final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // ShreddedPaper - handled in the region
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
     // Paper end - optimise chunk tick iteration
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 419742f225a63a14c987dcc926997953d605faf2..da73c6d12699456b5bb04ee554c58da3df759049 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -14,6 +14,7 @@ import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
 
+import io.multipaper.shreddedpaper.threading.ShreddedPaperChangesBroadcaster;
 import io.papermc.paper.util.TickThread;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -666,17 +667,20 @@ public class ServerChunkCache extends ChunkSource {
             // Paper - optimise chunk tick iteration
                 //this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timing // Purpur
             // Paper start - optimise chunk tick iteration
-            if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
-                it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
-                this.chunkMap.needsChangeBroadcasting.clear();
-                for (ChunkHolder holder : copy) {
-                    holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
-                    if (holder.needsBroadcastChanges()) {
-                        // I DON'T want to KNOW what DUMB plugins might be doing.
-                        this.chunkMap.needsChangeBroadcasting.add(holder);
-                    }
-                }
-            }
+            // ShreddedPaper start -  // ShreddedPaper - handled in the region
+            ShreddedPaperChangesBroadcaster.broadcastChangesMainThread();
+//            if (!this.chunkMap.needsChangeBroadcasting.isEmpty()) {
+//                it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ChunkHolder> copy = this.chunkMap.needsChangeBroadcasting.clone();
+//                this.chunkMap.needsChangeBroadcasting.clear();
+//                for (ChunkHolder holder : copy) {
+//                    holder.broadcastChanges(holder.getFullChunkNowUnchecked()); // LevelChunks are NEVER unloaded
+//                    if (holder.needsBroadcastChanges()) {
+//                        // I DON'T want to KNOW what DUMB plugins might be doing.
+//                        this.chunkMap.needsChangeBroadcasting.add(holder);
+//                    }
+//                }
+//            }
+            // ShreddedPaper end - handled in the region
             // Paper end - optimise chunk tick iteration
                 //this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timing // Purpur
             // Paper - optimise chunk tick iteration
