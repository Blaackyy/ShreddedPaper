From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 19 May 2024 18:20:55 +0900
Subject: [PATCH] Chunk unloading


diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index e79e07d58a7c82bf9390a473bf61e69a731fe279..1174042c7f8f915d621aebacf61a080cc39819b4 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -22,6 +22,7 @@ import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import com.mojang.logging.LogUtils;
 import io.multipaper.shreddedpaper.ShreddedPaper;
+import io.multipaper.shreddedpaper.region.LevelChunkRegion;
 import io.multipaper.shreddedpaper.util.SimpleStampedLock;
 import it.unimi.dsi.fastutil.longs.Long2ByteLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -75,7 +76,7 @@ public final class ChunkHolderManager {
 
     private final ConcurrentLong2ReferenceChainedHashTable<SortedArraySet<Ticket<?>>> tickets = new ConcurrentLong2ReferenceChainedHashTable<>();
     private final ConcurrentLong2ReferenceChainedHashTable<Long2IntOpenHashMap> sectionToChunkToExpireCount = new ConcurrentLong2ReferenceChainedHashTable<>();
-    final ChunkUnloadQueue unloadQueue;
+    // final ChunkUnloadQueue unloadQueue; // ShreddedPaper - use our own unload queue
 
     private final ConcurrentLong2ReferenceChainedHashTable<NewChunkHolder> chunkHolders = ConcurrentLong2ReferenceChainedHashTable.createWithCapacity(16384, 0.25f);
     private final ServerLevel world;
@@ -109,7 +110,7 @@ public final class ChunkHolderManager {
         this.world = world;
         this.taskScheduler = taskScheduler;
         this.ticketLockArea = new ReentrantAreaLock(taskScheduler.getChunkSystemLockShift());
-        this.unloadQueue = new ChunkUnloadQueue(((ChunkSystemServerLevel)world).moonrise$getRegionChunkShift());
+        // this.unloadQueue = new ChunkUnloadQueue(((ChunkSystemServerLevel)world).moonrise$getRegionChunkShift()); // ShreddedPaper - use our own unload queue
     }
 
     public boolean processTicketUpdates(final int posX, final int posZ) {
@@ -1059,88 +1060,100 @@ public final class ChunkHolderManager {
     }
 
     // note: never call while inside the chunk system, this will absolutely break everything
-    public void processUnloads() {
+    public void processUnloads(LevelChunkRegion region) { // ShreddedPaper
+        if (region.unloadQueue.isEmpty()) return; // ShreddedPaper
+
         TickThread.ensureTickThread("Cannot unload chunks off-main");
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
         }
-        final int sectionShift = this.unloadQueue.coordinateShift; // sectionShift <= lock shift
-        final List<ChunkUnloadQueue.SectionToUnload> unloadSectionsForRegion = this.unloadQueue.retrieveForAllRegions();
-        int unloadCountTentative = 0;
-        for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
-            final ChunkUnloadQueue.UnloadSection section
-                = this.unloadQueue.getSectionUnsynchronized(sectionRef.sectionX(), sectionRef.sectionZ());
-
-            if (section == null) {
-                // removed concurrently
-                continue;
-            }
-
-            // technically reading the size field is unsafe, and it may be incorrect.
-            // We assume that the error here cumulatively goes away over many ticks. If it did not, then it is possible
-            // for chunks to never unload or not unload fast enough.
-            unloadCountTentative += section.chunks.size();
-        }
-
-        if (unloadCountTentative <= 0) {
-            // no work to do
-            return;
-        }
+//        final int sectionShift = this.unloadQueue.coordinateShift; // sectionShift <= lock shift
+//        final List<ChunkUnloadQueue.SectionToUnload> unloadSectionsForRegion = this.unloadQueue.retrieveForAllRegions();
+//        int unloadCountTentative = 0;
+//        for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
+//            final ChunkUnloadQueue.UnloadSection section
+//                = this.unloadQueue.getSectionUnsynchronized(sectionRef.sectionX(), sectionRef.sectionZ());
+//
+//            if (section == null) {
+//                // removed concurrently
+//                continue;
+//            }
+//
+//            // technically reading the size field is unsafe, and it may be incorrect.
+//            // We assume that the error here cumulatively goes away over many ticks. If it did not, then it is possible
+//            // for chunks to never unload or not unload fast enough.
+//            unloadCountTentative += section.chunks.size();
+//        }
+//
+//        if (unloadCountTentative <= 0) {
+//            // no work to do
+//            return;
+//        }
 
         // We do need to process updates here so that any addTicket that is synchronised before this call does not go missed.
         this.processTicketUpdates();
 
-        final int toUnloadCount = Math.max(50, (int)(unloadCountTentative * 0.05));
+        final int toUnloadCount = 50; // Math.max(50, (int)(unloadCountTentative * 0.05)); // ShreddedPaper
         int processedCount = 0;
 
-        for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
+        // for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) { // ShreddedPaper
             final List<NewChunkHolder> stage1 = new ArrayList<>();
             final List<NewChunkHolder.UnloadState> stage2 = new ArrayList<>();
 
-            final int sectionLowerX = sectionRef.sectionX() << sectionShift;
-            final int sectionLowerZ = sectionRef.sectionZ() << sectionShift;
+            final int sectionLowerX = region.getRegionPos().getLowerChunkX(); // sectionRef.sectionX() << sectionShift; // ShreddedPaper
+            final int sectionLowerZ = region.getRegionPos().getLowerChunkZ(); // sectionRef.sectionZ() << sectionShift; // ShreddedPaper
 
             // stage 1: set up for stage 2 while holding critical locks
             ReentrantAreaLock.Node ticketLock = this.ticketLockArea.lock(sectionLowerX, sectionLowerZ);
             try {
                 final ReentrantAreaLock.Node scheduleLock = this.taskScheduler.schedulingLockArea.lock(sectionLowerX, sectionLowerZ);
                 try {
-                    final ChunkUnloadQueue.UnloadSection section
-                        = this.unloadQueue.getSectionUnsynchronized(sectionRef.sectionX(), sectionRef.sectionZ());
-
-                    if (section == null) {
-                        // removed concurrently
-                        continue;
-                    }
-
-                    // collect the holders to run stage 1 on
-                    final int sectionCount = section.chunks.size();
-
-                    if ((sectionCount + processedCount) <= toUnloadCount) {
-                        // we can just drain the entire section
-
-                        for (final LongIterator iterator = section.chunks.iterator(); iterator.hasNext();) {
-                            final NewChunkHolder holder = this.chunkHolders.get(iterator.nextLong());
-                            if (holder == null) {
-                                throw new IllegalStateException();
-                            }
-                            stage1.add(holder);
-                        }
-
-                        // remove section
-                        this.unloadQueue.removeSection(sectionRef.sectionX(), sectionRef.sectionZ());
-                    } else {
-                        // processedCount + len = toUnloadCount
-                        // we cannot drain the entire section
-                        for (int i = 0, len = toUnloadCount - processedCount; i < len; ++i) {
-                            final NewChunkHolder holder = this.chunkHolders.get(section.chunks.removeFirstLong());
-                            if (holder == null) {
-                                throw new IllegalStateException();
-                            }
-                            stage1.add(holder);
+                    // ShreddedPaper start
+                    while (processedCount < toUnloadCount && !region.unloadQueue.isEmpty()) {
+                        final NewChunkHolder holder = this.chunkHolders.get(region.unloadQueue.removeFirstLong());
+                        if (holder == null) {
+                            continue;
                         }
+                        stage1.add(holder);
+                        processedCount++;
                     }
+                    // ShreddedPaper end
+//                    final ChunkUnloadQueue.UnloadSection section
+//                        = this.unloadQueue.getSectionUnsynchronized(sectionRef.sectionX(), sectionRef.sectionZ());
+//
+//                    if (section == null) {
+//                        // removed concurrently
+//                        continue;
+//                    }
+//
+//                    // collect the holders to run stage 1 on
+//                    final int sectionCount = section.chunks.size();
+//
+//                    if ((sectionCount + processedCount) <= toUnloadCount) {
+//                        // we can just drain the entire section
+//
+//                        for (final LongIterator iterator = section.chunks.iterator(); iterator.hasNext();) {
+//                            final NewChunkHolder holder = this.chunkHolders.get(iterator.nextLong());
+//                            if (holder == null) {
+//                                throw new IllegalStateException();
+//                            }
+//                            stage1.add(holder);
+//                        }
+//
+//                        // remove section
+//                        this.unloadQueue.removeSection(sectionRef.sectionX(), sectionRef.sectionZ());
+//                    } else {
+//                        // processedCount + len = toUnloadCount
+//                        // we cannot drain the entire section
+//                        for (int i = 0, len = toUnloadCount - processedCount; i < len; ++i) {
+//                            final NewChunkHolder holder = this.chunkHolders.get(section.chunks.removeFirstLong());
+//                            if (holder == null) {
+//                                throw new IllegalStateException();
+//                            }
+//                            stage1.add(holder);
+//                        }
+//                    }
 
                     // run stage 1
                     for (int i = 0, len = stage1.size(); i < len; ++i) {
@@ -1203,11 +1216,11 @@ public final class ChunkHolderManager {
                 this.ticketLockArea.unlock(ticketLock);
             }
 
-            processedCount += stage1.size();
-
-            if (processedCount >= toUnloadCount) {
-                break;
-            }
+//            processedCount += stage1.size();
+//
+//            if (processedCount >= toUnloadCount) {
+//                break;
+//            }
         }
     }
 
@@ -1400,7 +1413,7 @@ public final class ChunkHolderManager {
     public JsonObject getDebugJson() {
         final JsonObject ret = new JsonObject();
 
-        ret.add("unload_queue", this.unloadQueue.toDebugJson());
+        // ret.add("unload_queue", this.unloadQueue.toDebugJson()); // ShreddedPaper - removed unloadQueue
 
         final JsonArray holders = new JsonArray();
         ret.add("chunkholders", holders);
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
index bb68bb0a750b7bc0617b1c1765b9ab6a442c3ff1..83d605bb8046f1d080a322c82448ff7d056bcb80 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -55,6 +55,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
@@ -773,13 +774,13 @@ public final class NewChunkHolder {
             // ensure in unload queue
             if (!this.inUnloadQueue) {
                 this.inUnloadQueue = true;
-                this.scheduler.chunkHolderManager.unloadQueue.addChunk(this.chunkX, this.chunkZ);
+                world.chunkSource.tickingRegions.getOrCreate(RegionPos.forChunk(vanillaChunkHolder.getPos())).unloadQueue.add(vanillaChunkHolder.getPos().longKey); // this.scheduler.chunkHolderManager.unloadQueue.addChunk(this.chunkX, this.chunkZ); // ShreddedPaper
             }
         } else {
             // ensure not in unload queue
             if (this.inUnloadQueue) {
                 this.inUnloadQueue = false;
-                this.scheduler.chunkHolderManager.unloadQueue.removeChunk(this.chunkX, this.chunkZ);
+                Optional.ofNullable(world.chunkSource.tickingRegions.get(RegionPos.forChunk(vanillaChunkHolder.getPos()))).ifPresent(v -> v.unloadQueue.remove(vanillaChunkHolder.getPos().longKey)); // this.scheduler.chunkHolderManager.unloadQueue.removeChunk(this.chunkX, this.chunkZ); // ShreddedPaper
             }
         }
     }
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
index 8fba7684488e6cfee2562b6287e6ff8b90a5f145..9338b86709b5d7721b8ec4576e1e0ec9a4f90bcf 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -3,6 +3,7 @@ package io.multipaper.shreddedpaper.region;
 import ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet;
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
 
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
@@ -24,6 +25,7 @@ public class LevelChunkRegion {
     private final ConcurrentLinkedQueue<DelayedTask> scheduledTasks = new ConcurrentLinkedQueue<>(); // Writable tasks
     private final PrioritisedThreadedTaskQueue internalTasks = new PrioritisedThreadedTaskQueue(); // Read-only tasks
     private final ObjectOpenHashSet<ServerPlayer> players = new ObjectOpenHashSet<>();
+    public final LongLinkedOpenHashSet unloadQueue = new LongLinkedOpenHashSet();
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -129,6 +131,8 @@ public class LevelChunkRegion {
                 && tickingEntities.size() == 0
                 && scheduledTasks.isEmpty()
                 && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled()
-                && players.isEmpty();
+                && players.isEmpty()
+                && unloadQueue.isEmpty()
+                ;
     }
 }
diff --git a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
index a51db4e5505903376656aad80971f8faabc0cc53..3bac1c9388523a5b807f9400877d4ee6140d553a 100644
--- a/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
+++ b/src/main/java/io/multipaper/shreddedpaper/threading/ShreddedPaperChunkTicker.java
@@ -58,6 +58,8 @@ public class ShreddedPaperChunkTicker {
 
             while (region.getInternalTaskQueue().executeTask()) ;
 
+            level.chunkTaskScheduler.chunkHolderManager.processUnloads(region);
+
             region.forEachTickingEntity(entity -> {
                 CraftEntity bukkitEntity = entity.getBukkitEntityRaw();
                 if (bukkitEntity != null && !entity.isRemoved()) { // Entity could have been removed by another entity's task
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 187c9e6aab99ee88e879d21f76f801274bed1021..59d7e6244cde58c21698b9c2ab5f59befad440c2 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -412,9 +412,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         throw new UnsupportedOperationException(); // Paper - rewrite chunk system
     }
 
+    private int deleteme = 0; // ShreddedPaper - TODO look into autoSave call here - should it be put on the region thread?
     private void processUnloads(BooleanSupplier shouldKeepTicking) {
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processUnloads(); // Paper - rewrite chunk system
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.autoSave(); // Paper - rewrite chunk system
+        // ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processUnloads(); // Paper - rewrite chunk system// ShreddedPaper - we unload chunks on the chunk thread
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.autoSave(); if (deleteme++ == 0) new Exception("Check this autosave").printStackTrace();// Paper - rewrite chunk system // ShreddedPaper - TODO look into autoSave call here - should it be put on the region thread?
 
     }
 
