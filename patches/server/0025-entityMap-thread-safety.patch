From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Wed, 10 Jul 2024 23:18:32 +0900
Subject: [PATCH] entityMap thread safety


diff --git a/src/main/java/io/multipaper/shreddedpaper/util/Int2ObjectMapWrapper.java b/src/main/java/io/multipaper/shreddedpaper/util/Int2ObjectMapWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..28bb91a25b7e473f4e2af48561e6b1086986082d
--- /dev/null
+++ b/src/main/java/io/multipaper/shreddedpaper/util/Int2ObjectMapWrapper.java
@@ -0,0 +1,261 @@
+package io.multipaper.shreddedpaper.util;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.ints.AbstractInt2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectFunction;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import it.unimi.dsi.fastutil.objects.ObjectArraySet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+
+public class Int2ObjectMapWrapper<V> implements Int2ObjectMap<V> {
+    private final Map<Integer, V> map;
+    private boolean hasPrintedDepricatedWarning = false;
+
+    public Int2ObjectMapWrapper(Map<Integer, V> m) {
+        this.map = m;
+    }
+
+    private void printDepricatedWarning() {
+        if (!this.hasPrintedDepricatedWarning) {
+            this.hasPrintedDepricatedWarning = true;
+            LogUtils.getClassLogger().warn("Iterating on the Int2ObjectMapWrapper is inefficient. Please iterate directly on the wrapped map instead.", new Exception("Stack trace"));
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.map.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.map.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return this.map.containsValue(value);
+    }
+
+    @Override
+    public void putAll(@NotNull Map<? extends Integer, ? extends V> m) {
+        this.map.putAll(m);
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        printDepricatedWarning();
+        ObjectArraySet<Entry<V>> set = new ObjectArraySet<>(this.size());
+        this.map.forEach((k, v) -> set.add(new AbstractInt2ObjectMap.BasicEntry<>(k, v)));
+        return set;
+    }
+
+    @NotNull
+    @Override
+    public IntSet keySet() {
+        printDepricatedWarning();
+        return new IntArraySet(this.map.keySet());
+    }
+
+    @NotNull
+    @Override
+    public ObjectCollection<V> values() {
+        printDepricatedWarning();
+        return new ObjectArrayList<>(this.map.values());
+    }
+
+    @Override
+    public V get(int key) {
+        return this.map.get(key);
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return this.map.containsKey(key);
+    }
+
+    @Override
+    public V getOrDefault(final int key, final V defaultValue) {
+        return this.map.getOrDefault(key, defaultValue);
+    }
+
+    @Override
+    public V getOrDefault(final Object key, final V defaultValue) {
+        return this.map.getOrDefault(key, defaultValue);
+    }
+
+    @Override
+    public V putIfAbsent(final int key, final V value) {
+        return this.map.putIfAbsent(key, value);
+    }
+
+    @Override
+    public boolean remove(final int key, final Object value) {
+        return this.map.remove(key, value);
+    }
+
+    @Override
+    public boolean replace(final int key, final V oldValue, final V newValue) {
+        return this.map.replace(key, oldValue, newValue);
+    }
+
+    @Override
+    public V replace(final int key, final V value) {
+        return containsKey(key) ? put(key, value) : defaultReturnValue();
+    }
+
+    @Override
+    public V computeIfAbsent(final int key, final java.util.function.IntFunction<? extends V> mappingFunction) {
+        return this.map.computeIfAbsent(key, mappingFunction::apply);
+    }
+
+    @Override
+    public V computeIfAbsent(final int key, final Int2ObjectFunction<? extends V> mappingFunction) {
+        return this.map.computeIfAbsent(key, mappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(final int key, final java.util.function.BiFunction<? super Integer, ? super V, ? extends V> remappingFunction) {
+        return this.map.computeIfPresent(key, remappingFunction);
+    }
+
+    @Override
+    public V compute(final int key, final java.util.function.BiFunction<? super Integer, ? super V, ? extends V> remappingFunction) {
+        return this.map.compute(key, remappingFunction);
+    }
+
+    @Override
+    public V merge(final int key, final V value, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return this.map.merge(key, value, remappingFunction);
+    }
+
+    @Override
+    public V put(final int key, final V value) {
+        return this.map.put(key, value);
+    }
+
+    @Override
+    public V remove(final int key) {
+        return this.map.remove(key);
+    }
+
+    @Override
+    public V put(final Integer key, final V value) {
+        return this.map.put(key, value);
+    }
+
+    @Override
+    public V get(final Object key) {
+        return this.map.get(key);
+    }
+
+    @Override
+    public V remove(final Object key) {
+        return this.map.remove(key);
+    }
+
+    @Override
+    public void clear() {
+        this.map.clear();
+    }
+
+    @NotNull
+    @Override
+    public ObjectSet<Map.Entry<Integer, V>> entrySet() {
+        printDepricatedWarning();
+        return new ObjectArraySet<>(this.map.entrySet());
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return this.map.containsKey(key);
+    }
+
+    @Override
+    public void forEach(BiConsumer<? super Integer, ? super V> consumer) {
+        this.map.forEach(consumer);
+    }
+
+    @Override
+    public void replaceAll(BiFunction<? super Integer, ? super V, ? extends V> function) {
+        this.map.replaceAll(function);
+    }
+
+    @Nullable
+    @Override
+    public V putIfAbsent(Integer key, V value) {
+        return this.map.putIfAbsent(key, value);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return this.map.remove(key, value);
+    }
+
+    @Override
+    public boolean replace(Integer key, V oldValue, V newValue) {
+        return this.map.replace(key, oldValue, newValue);
+    }
+
+    @Nullable
+    @Override
+    public V replace(Integer key, V value) {
+        return this.map.replace(key, value);
+    }
+
+    @Override
+    public V computeIfAbsent(Integer key, @NotNull Function<? super Integer, ? extends V> mappingFunction) {
+        return this.map.computeIfAbsent(key, mappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(Integer key, @NotNull BiFunction<? super Integer, ? super V, ? extends V> remappingFunction) {
+        return this.map.computeIfPresent(key, remappingFunction);
+    }
+
+    @Override
+    public V compute(Integer key, @NotNull BiFunction<? super Integer, ? super V, ? extends V> remappingFunction) {
+        return this.map.compute(key, remappingFunction);
+    }
+
+    @Override
+    public V merge(Integer key, @NotNull V value, @NotNull BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return this.map.merge(key, value, remappingFunction);
+    }
+
+    @Override
+    public int hashCode() {
+        return this.map.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return this == obj || (obj instanceof Int2ObjectMapWrapper<?> wrapper && this.map.equals(wrapper.map));
+    }
+
+    @Override
+    public String toString() {
+        return this.getClass().getSimpleName() + this.map.toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 8d202aa75cb5b9974365d99ced46f6262ea6b4dd..d0251435eadb1b2a478ae0e9d48e278e643b39f6 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -13,6 +13,7 @@ import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
+import io.multipaper.shreddedpaper.util.Int2ObjectMapWrapper;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
@@ -42,6 +43,7 @@ import java.util.Set;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
@@ -140,7 +142,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public final AtomicInteger tickingGenerated; // Paper - public
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap; // ShreddedPaper - Wrapper of ConcurrentHashMap to maintain plugin support
+    public final ConcurrentHashMap<Integer, ChunkMap.TrackedEntity> entityConcurrentMap; // ShreddedPaper - Wrapper of ConcurrentHashMap to maintain plugin support
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
@@ -254,7 +257,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityConcurrentMap = new ConcurrentHashMap<>(); // ShreddedPaper - Wrapper of ConcurrentHashMap to maintain plugin support
+        this.entityMap = new Int2ObjectMapWrapper(this.entityConcurrentMap); // ShreddedPaper - Wrapper of ConcurrentHashMap to maintain plugin support
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.chunkSaveCooldowns = new Long2LongOpenHashMap();
         this.unloadQueue = Queues.newConcurrentLinkedQueue();
@@ -1091,9 +1095,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void addEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp("entity track"); // Spigot
         // Paper start - ignore and warn about illegal addEntity calls instead of crashing server
-        if (!entity.valid || entity.level() != this.level || this.entityMap.containsKey(entity.getId())) {
+        if (!entity.valid || entity.level() != this.level || this.entityConcurrentMap.containsKey(entity.getId())) { // ShreddedPaper - use entityConcurrentMap
             LOGGER.error("Illegal ChunkMap::addEntity for world " + this.level.getWorld().getName()
-                + ": " + entity  + (this.entityMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable());
+                + ": " + entity  + (this.entityConcurrentMap.containsKey(entity.getId()) ? " ALREADY CONTAINED (This would have crashed your server)" : ""), new Throwable()); // ShreddedPaper - use entityConcurrentMap
             return;
         }
         // Paper end - ignore and warn about illegal addEntity calls instead of crashing server
@@ -1106,19 +1110,19 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (i != 0) {
                 int j = entitytypes.updateInterval();
 
-                if (this.entityMap.containsKey(entity.getId())) {
+                if (this.entityConcurrentMap.containsKey(entity.getId())) { // ShreddedPaper - use entityConcurrentMap
                     throw (IllegalStateException) Util.pauseInIde(new IllegalStateException("Entity is already tracked!"));
                 } else {
                     ChunkMap.TrackedEntity playerchunkmap_entitytracker = new ChunkMap.TrackedEntity(entity, i, j, entitytypes.trackDeltas());
 
                     entity.tracker = playerchunkmap_entitytracker; // Paper - Fast access to tracker
-                    this.entityMap.put(entity.getId(), playerchunkmap_entitytracker);
+                    this.entityConcurrentMap.put(entity.getId(), playerchunkmap_entitytracker); // ShreddedPaper - use entityConcurrentMap
                     playerchunkmap_entitytracker.updatePlayers(entity.getPlayersInTrackRange()); // Paper - don't search all players
                     if (entity instanceof ServerPlayer) {
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator objectiterator = this.entityConcurrentMap.values().iterator(); // ShreddedPaper - use entityConcurrentMap
 
                         while (objectiterator.hasNext()) {
                             ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1138,7 +1142,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof ServerPlayer entityplayer) {
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator objectiterator = this.entityConcurrentMap.values().iterator(); // ShreddedPaper - use entityConcurrentMap
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1147,7 +1151,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
         }
 
-        ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) this.entityMap.remove(entity.getId());
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) this.entityConcurrentMap.remove(entity.getId()); // ShreddedPaper - use entityConcurrentMap
 
         if (playerchunkmap_entitytracker1 != null) {
             playerchunkmap_entitytracker1.broadcastRemoved();
@@ -1160,7 +1164,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         if (true) return; // ShreddedPaper - handle ourselves
         //this.level.timings.tracker1.startTiming(); // Purpur
         try {
-            for (TrackedEntity tracker : this.entityMap.values()) {
+            for (TrackedEntity tracker : this.entityConcurrentMap.values()) { // ShreddedPaper - use entityConcurrentMap
                 // update tracker entry
                 tracker.updatePlayers(tracker.entity.getPlayersInTrackRange());
             }
@@ -1171,7 +1175,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         //this.level.timings.tracker2.startTiming(); // Purpur
         try {
-            for (TrackedEntity tracker : this.entityMap.values()) {
+            for (TrackedEntity tracker : this.entityConcurrentMap.values()) { // ShreddedPaper - use entityConcurrentMap
                 tracker.serverEntity.sendChanges();
             }
         } finally {
@@ -1189,7 +1193,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - optimized tracker
         List<ServerPlayer> list = Lists.newArrayList();
         List<ServerPlayer> list1 = this.level.players();
-        ObjectIterator objectiterator = this.entityMap.values().iterator();
+        Iterator objectiterator = this.entityConcurrentMap.values().iterator(); // ShreddedPaper - use entityConcurrentMap
         //this.level.timings.tracker1.startTiming(); // Paper // Purpur
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
@@ -1218,7 +1222,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         //this.level.timings.tracker1.stopTiming(); // Paper // Purpur
 
         if (!list.isEmpty()) {
-            objectiterator = this.entityMap.values().iterator();
+            objectiterator = this.entityConcurrentMap.values().iterator(); // ShreddedPaper - use entityConcurrentMap
 
             //this.level.timings.tracker2.startTiming(); // Paper // Purpur
             while (objectiterator.hasNext()) {
@@ -1231,7 +1235,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     public void broadcast(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityConcurrentMap.get(entity.getId()); // ShreddedPaper - use entityConcurrentMap
 
         if (playerchunkmap_entitytracker != null) {
             playerchunkmap_entitytracker.broadcast(packet);
@@ -1240,7 +1244,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     protected void broadcastAndSend(Entity entity, Packet<?> packet) {
-        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityMap.get(entity.getId());
+        ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) this.entityConcurrentMap.get(entity.getId()); // ShreddedPaper - use entityConcurrentMap
 
         if (playerchunkmap_entitytracker != null) {
             playerchunkmap_entitytracker.broadcastAndSend(packet);
diff --git a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
index dff0e7b08b973a1b29f916e63d3e4778d6c56cdc..224cae0c2560f60ac68112ee35de0d8b18796fea 100644
--- a/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/src/main/java/net/minecraft/world/entity/item/PrimedTnt.java
@@ -8,6 +8,7 @@ import net.minecraft.nbt.NbtUtils;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.LivingEntity;
@@ -114,7 +115,7 @@ public class PrimedTnt extends Entity implements TraceableEntity {
              */
             // Send position and velocity updates to nearby players on every tick while the TNT is in water.
             // This does pretty well at keeping their clients in sync with the server.
-            net.minecraft.server.level.ChunkMap.TrackedEntity ete = ((net.minecraft.server.level.ServerLevel)this.level()).getChunkSource().chunkMap.entityMap.get(this.getId());
+            net.minecraft.server.level.ChunkMap.TrackedEntity ete = ((ServerLevel)this.level()).getChunkSource().chunkMap.entityConcurrentMap.get(this.getId()); // ShreddedPaper - use entityConcurrentMap
             if (ete != null) {
                 net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket velocityPacket = new net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket(this);
                 net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket positionPacket = new net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket(this);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index bd60758e8291821c66bd82a5d23682959b915136..e4557f9327d404b3d7eb98d63396ab2fff8987de 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2004,7 +2004,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(CraftSound.bukkitToMinecraftHolder(sound), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityConcurrentMap.get(entity.getEntityId()); // ShreddedPaper - use entityConcurrentMap
         if (entityTracker != null) {
             entityTracker.broadcastAndSend(packet);
         }
@@ -2016,7 +2016,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(Holder.direct(SoundEvent.createVariableRangeEvent(new ResourceLocation(sound))), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityConcurrentMap.get(entity.getEntityId()); // ShreddedPaper - use entityConcurrentMap
         if (entityTracker != null) {
             entityTracker.broadcastAndSend(packet);
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 67d7eede1543599497cd31b7de308e1caf952a08..182632dca46fd36b1e24dd875dae965cc28b98b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -724,7 +724,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         ImmutableSet.Builder<Player> players = ImmutableSet.builder();
 
         ServerLevel world = ((CraftWorld) this.getWorld()).getHandle();
-        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityMap.get(this.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityConcurrentMap.get(this.getEntityId()); // ShreddedPaper - use entityConcurrentMap
 
         if (entityTracker != null) {
             for (ServerPlayerConnection connection : entityTracker.seenBy) {
@@ -1028,7 +1028,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
 
         ServerLevel world = ((CraftWorld) this.getWorld()).getHandle();
-        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityMap.get(this.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityConcurrentMap.get(this.getEntityId()); // ShreddedPaper - use entityConcurrentMap
 
         if (entityTracker == null) {
             return;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index c12484e13ff2b06b9bad7c5b2bbf9e82c1cbc989..940f2716afc37684f92a7bd2b2bea6e0b9bbe6a7 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2052,7 +2052,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private void unregisterEntity(Entity other) {
         // Paper end
         ChunkMap tracker = ((ServerLevel) this.getHandle().level()).getChunkSource().chunkMap;
-        ChunkMap.TrackedEntity entry = tracker.entityMap.get(other.getId());
+        ChunkMap.TrackedEntity entry = tracker.entityConcurrentMap.get(other.getId()); // ShreddedPaper - use entityConcurrentMap
         if (entry != null) {
             entry.removePlayer(this.getHandle());
         }
@@ -2149,7 +2149,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             if (original != null) otherPlayer.setUUID(original); // Paper - uuid override
         }
 
-        ChunkMap.TrackedEntity entry = tracker.entityMap.get(other.getId());
+        ChunkMap.TrackedEntity entry = tracker.entityConcurrentMap.get(other.getId()); // ShreddedPaper - use entityConcurrentMap
         if (entry != null && !entry.seenBy.contains(this.getHandle().connection)) {
             entry.updatePlayer(this.getHandle());
         }
