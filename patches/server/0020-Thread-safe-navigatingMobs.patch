From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 5 May 2024 17:02:23 +0900
Subject: [PATCH] Thread-safe navigatingMobs


diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
index 59bf50aab611ed8209e7e1b825bd593027b025ee..df82710cd48f1adeeff7a5b5922606285013abd3 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -10,6 +10,7 @@ import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.block.entity.TickingBlockEntity;
 import net.minecraft.world.level.chunk.LevelChunk;
 
@@ -32,6 +33,7 @@ public class LevelChunkRegion {
     public final LongLinkedOpenHashSet unloadQueue = new LongLinkedOpenHashSet();
     public final List<TickingBlockEntity> tickingBlockEntities = new ReferenceArrayList<>();
     public final List<TickingBlockEntity> pendingBlockEntityTickers = new ReferenceArrayList<>();
+    private final ObjectOpenHashSet<Mob> navigatingMobs = new ObjectOpenHashSet<>();
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -115,6 +117,18 @@ public class LevelChunkRegion {
         return this.players.isEmpty() ? List.of() : new ObjectArrayList<>(this.players);
     }
 
+    public synchronized void addNavigationMob(Mob mob) {
+        navigatingMobs.add(mob);
+    }
+
+    public synchronized void removeNavigationMob(Mob mob) {
+        navigatingMobs.remove(mob);
+    }
+
+    public synchronized void collectNavigatingMobs(List<Mob> collection) {
+        collection.addAll(this.navigatingMobs);
+    }
+
     public RegionPos getRegionPos() {
         return regionPos;
     }
@@ -158,6 +172,7 @@ public class LevelChunkRegion {
                 && tickingBlockEntities.isEmpty()
                 && pendingBlockEntityTickers.isEmpty()
                 && trackedEntities.isEmpty()
+                && navigatingMobs.isEmpty()
                 ;
     }
 }
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
index 634e385d8d8af8848ca7a82a990e71201b97fcbb..3b77254f09bf9172c2de8a1fc3cec83e0ca641a3 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
@@ -1,11 +1,14 @@
 package io.multipaper.shreddedpaper.region;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionLocker;
 import io.multipaper.shreddedpaper.util.SimpleStampedLock;
 
 import java.util.ArrayList;
@@ -103,6 +106,10 @@ public class LevelChunkRegionMap {
 
         entity.previousTrackedChunkPosRegion = entity.chunkPosition();
         getOrCreate(RegionPos.forChunk(entity.chunkPosition())).addTrackedEntity(entity);
+
+        if (entity instanceof Mob mob) {
+            getOrCreate(RegionPos.forChunk(entity.chunkPosition())).addNavigationMob(mob);
+        }
     }
 
     public void removeTrackedEntity(Entity entity) {
@@ -110,6 +117,10 @@ public class LevelChunkRegionMap {
             throw new IllegalStateException("Entity is not being tracked " + entity);
         }
 
+        if (entity instanceof Mob mob) {
+            getOrCreate(RegionPos.forChunk(entity.chunkPosition())).removeNavigationMob(mob);
+        }
+
         getOrCreate(RegionPos.forChunk(entity.previousTrackedChunkPosRegion)).removeTrackedEntity(entity);
         entity.previousTrackedChunkPosRegion = null;
     }
@@ -128,6 +139,11 @@ public class LevelChunkRegionMap {
             entity.previousTrackedChunkPosRegion = newChunkPos;
             getOrCreate(fromRegion).removeTrackedEntity(entity);
             getOrCreate(toRegion).addTrackedEntity(entity);
+
+            if (entity instanceof Mob mob) {
+                getOrCreate(fromRegion).removeNavigationMob(mob);
+                getOrCreate(toRegion).addNavigationMob(mob);
+            }
         }
     }
 
@@ -182,4 +198,29 @@ public class LevelChunkRegionMap {
             getOrCreate(toRegion).addPlayer(player);
         }
     }
+
+    public List<Mob> collectRelevantNavigatingMobs(RegionPos regionPos) {
+        if (!level.chunkScheduler.getRegionLocker().hasLock(regionPos)) {
+            // We care about the navigating mobs in at least this region, ensure it's locked
+            throw new IllegalStateException("Collecting navigating mobs outside of region's thread");
+        }
+
+        ObjectArrayList<Mob> navigatingMobs = new ObjectArrayList<>();
+
+        for (int x = -ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; x <= ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; x++) {
+            for (int z = -ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; z <= ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; z++) {
+                RegionPos i = new RegionPos(regionPos.x + x, regionPos.z + z);
+
+                // Only collect mobs from regions that are locked - if it's not locked, it should be too far away to matter
+                if (!level.chunkScheduler.getRegionLocker().hasLock(i)) continue;
+
+                LevelChunkRegion region = get(i);
+                if (region == null) continue;
+
+                region.collectNavigatingMobs(navigatingMobs);
+            }
+        }
+
+        return navigatingMobs;
+    }
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 33423970ffb7c339e6177b9aaa9f137c2d89ff22..43ee7cd77617bb7adaa55b1d4d88e6bee8d40e49 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -346,6 +346,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     public boolean pollTask() {
+        if (ShreddedPaperTickThread.isShreddedPaperTickThread()) return false; // ShreddedPaper - don't run main thread tasks on worker threads
         return this.mainThreadProcessor.pollTask();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index a9e61c13ddded1f563a6ce67fba50a614da0837c..386adc0405a0b210094d096723fe25d19e14f7b0 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -208,7 +208,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     public final LevelTicksRegionProxy<Fluid> fluidTicks; // ShreddedPaper
     private final PathTypeCache pathTypesByPosCache;
     final Set<Mob> navigatingMobs;
-    volatile boolean isUpdatingNavigations;
+    final ThreadLocal<Boolean> isUpdatingNavigations = ThreadLocal.withInitial(() -> false); // ShreddedPaper - make thread local
     protected final Raids raids;
     private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
     private final List<BlockEventData> blockEventsToReschedule;
@@ -1772,7 +1772,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get()) { // ShreddedPaper - use thread local
             String s = "recursive call to sendBlockUpdated";
 
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
@@ -1786,7 +1786,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.navigatingMobs.iterator();
+            Iterator iterator = chunkSource.tickingRegions.collectRelevantNavigatingMobs(RegionPos.forChunk(new ChunkPos(pos))).iterator(); // ShreddedPaper
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
@@ -1809,7 +1809,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
             }
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // ShreddedPaper - use thread local
                 iterator = list.iterator();
 
                 while (iterator.hasNext()) {
@@ -1818,7 +1818,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                     navigationabstract1.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // ShreddedPaper - use thread local
             }
 
         }
@@ -2614,7 +2614,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         }
 
         public void onTrackingStart(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            TickThread.ensureTickThread(entity, "entity register"); // org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot // ShreddedPaper
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.add(entityplayer);
@@ -2623,13 +2623,13 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.add(entityinsentient);
+                // ServerLevel.this.navigatingMobs.add(entityinsentient); // ShreddedPaper - handled ourselves
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
@@ -2660,7 +2660,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         }
 
         public void onTrackingEnd(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            TickThread.ensureTickThread(entity, "entity unregister"); // org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot // ShreddedPaper
             // Spigot start
             if ( entity instanceof Player )
             {
@@ -2705,13 +2705,13 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.remove(entityinsentient);
+                // ServerLevel.this.navigatingMobs.remove(entityinsentient); // ShreddedPaper - handled ourselves
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
