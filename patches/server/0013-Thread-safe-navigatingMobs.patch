From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 5 May 2024 17:02:23 +0900
Subject: [PATCH] Thread-safe navigatingMobs


diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
index dbba4f212ed7971fde0c9a714f376d169937f23c..83ce4c66cd6c965f93253f4d57f7b082dcb747d7 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegion.java
@@ -2,8 +2,10 @@ package io.multipaper.shreddedpaper.region;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedThreadedTaskQueue;
 import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.chunk.LevelChunk;
 
 import java.util.ArrayList;
@@ -19,6 +21,7 @@ public class LevelChunkRegion {
     private final IteratorSafeOrderedReferenceSet<Entity> tickingEntities = new IteratorSafeOrderedReferenceSet<>(); // Use IteratorSafeOrderedReferenceSet to maintain entity tick order
     private final ConcurrentLinkedQueue<DelayedTask> scheduledTasks = new ConcurrentLinkedQueue<>(); // Writable tasks
     private final PrioritisedThreadedTaskQueue internalTasks = new PrioritisedThreadedTaskQueue(); // Read-only tasks
+    private final ObjectOpenHashSet<Mob> navigatingMobs = new ObjectOpenHashSet<>();
 
     public LevelChunkRegion(ServerLevel level, RegionPos regionPos) {
         this.level = level;
@@ -70,6 +73,18 @@ public class LevelChunkRegion {
         return internalTasks;
     }
 
+    public synchronized void addNavigationMob(Mob mob) {
+        navigatingMobs.add(mob);
+    }
+
+    public synchronized void removeNavigationMob(Mob mob) {
+        navigatingMobs.remove(mob);
+    }
+
+    public synchronized void collectNavigatingMobs(List<Mob> collection) {
+        collection.addAll(this.navigatingMobs);
+    }
+
     public RegionPos getRegionPos() {
         return regionPos;
     }
@@ -104,6 +119,6 @@ public class LevelChunkRegion {
     }
 
     public boolean isEmpty() {
-        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled();
+        return levelChunks.isEmpty() && scheduledTasks.isEmpty() && internalTasks.getTotalTasksExecuted() >= internalTasks.getTotalTasksScheduled() && navigatingMobs.isEmpty();
     }
 }
diff --git a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
index af1f3ba71e44b4b49c106d1e45331641e030ec6c..9bb764ed50e337dc5e5e734372bd85411cf66274 100644
--- a/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
+++ b/src/main/java/io/multipaper/shreddedpaper/region/LevelChunkRegionMap.java
@@ -1,10 +1,13 @@
 package io.multipaper.shreddedpaper.region;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import io.multipaper.shreddedpaper.threading.ShreddedPaperRegionLocker;
 import io.multipaper.shreddedpaper.util.SimpleStampedLock;
 
 import java.util.ArrayList;
@@ -127,4 +130,36 @@ public class LevelChunkRegionMap {
         return runnable -> execute(regionPos, runnable);
     }
 
+    public void addNavigationMob(Mob mob) {
+        getOrCreate(RegionPos.forChunk(mob.chunkPosition())).addNavigationMob(mob);
+    }
+
+    public void removeNavigationMob(Mob mob) {
+        getOrCreate(RegionPos.forChunk(mob.chunkPosition())).removeNavigationMob(mob);
+    }
+
+    public List<Mob> collectRelevantNavigatingMobs(RegionPos regionPos) {
+        if (!level.chunkScheduler.getRegionLocker().hasLock(regionPos)) {
+            // We care about the navigating mobs in at least this region, ensure it's locked
+            throw new IllegalStateException("Collecting navigating mobs outside of region's thread");
+        }
+
+        ObjectArrayList<Mob> navigatingMobs = new ObjectArrayList<>();
+
+        for (int x = -ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; x <= ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; x++) {
+            for (int z = -ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; z <= ShreddedPaperRegionLocker.REGION_LOCK_RADIUS; z++) {
+                RegionPos i = new RegionPos(regionPos.x + x, regionPos.z + z);
+
+                // Only collect mobs from regions that are locked - if it's not locked, it should be too far away to matter
+                if (!level.chunkScheduler.getRegionLocker().hasLock(i)) continue;
+
+                LevelChunkRegion region = get(i);
+                if (region == null) continue;
+
+                region.collectNavigatingMobs(navigatingMobs);
+            }
+        }
+
+        return navigatingMobs;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 7d5fd9be6133ae7b160096026aa4e125141db5e3..a41816c6f0ca2d68a2eea25f513c8e10956d7813 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -414,6 +414,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public boolean pollTask() {
+        if (ShreddedPaperTickThread.isShreddedPaperTickThread()) return false; // ShreddedPaper - don't run main thread tasks on worker threads
         return this.mainThreadProcessor.pollTask();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 0946438c4b471f739c25a9d58b11c51d60e9ee82..8e184db1d87978c6e553b453c28b2c5d7f46b757 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -204,7 +205,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
     private final LevelTicks<Fluid> fluidTicks;
     private final PathTypeCache pathTypesByPosCache;
     final Set<Mob> navigatingMobs;
-    volatile boolean isUpdatingNavigations;
+    final ThreadLocal<Boolean> isUpdatingNavigations = ThreadLocal.withInitial(() -> false); // ShreddedPaper - make thread local
     protected final Raids raids;
     private final ObjectLinkedOpenHashSet<BlockEventData> blockEvents;
     private final List<BlockEventData> blockEventsToReschedule;
@@ -1916,7 +1917,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     @Override
     public void sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) {
-        if (this.isUpdatingNavigations) {
+        if (this.isUpdatingNavigations.get()) { // ShreddedPaper - use thread local
             String s = "recursive call to sendBlockUpdated";
 
             Util.logAndPauseIfInIde("recursive call to sendBlockUpdated", new IllegalStateException("recursive call to sendBlockUpdated"));
@@ -1930,7 +1931,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = this.navigatingMobs.iterator();
+            Iterator iterator = chunkSource.tickingRegions.collectRelevantNavigatingMobs(RegionPos.forChunk(new ChunkPos(pos))).iterator(); // ShreddedPaper
 
             while (iterator.hasNext()) {
                 // CraftBukkit start - fix SPIGOT-6362
@@ -1953,7 +1954,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             try {
-                this.isUpdatingNavigations = true;
+                this.isUpdatingNavigations.set(true); // ShreddedPaper - use thread local
                 iterator = list.iterator();
 
                 while (iterator.hasNext()) {
@@ -1962,7 +1963,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     navigationabstract1.recomputePath();
                 }
             } finally {
-                this.isUpdatingNavigations = false;
+                this.isUpdatingNavigations.set(false); // ShreddedPaper - use thread local
             }
 
         }
@@ -2778,7 +2779,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         public void onTrackingStart(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot
+            TickThread.ensureTickThread(entity, "entity register"); // org.spigotmc.AsyncCatcher.catchOp("entity register"); // Spigot // ShreddedPaper
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer entityplayer) {
                 ServerLevel.this.players.add(entityplayer);
@@ -2786,13 +2787,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.add(entityinsentient);
+                chunkSource.tickingRegions.addNavigationMob(entityinsentient); // ServerLevel.this.navigatingMobs.add(entityinsentient); // ShreddedPaper
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
@@ -2823,7 +2824,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         public void onTrackingEnd(Entity entity) {
-            org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot
+            TickThread.ensureTickThread(entity, "entity unregister"); // org.spigotmc.AsyncCatcher.catchOp("entity unregister"); // Spigot // ShreddedPaper
             // Spigot start
             if ( entity instanceof Player )
             {
@@ -2867,13 +2868,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
 
             if (entity instanceof Mob entityinsentient) {
-                if (false && ServerLevel.this.isUpdatingNavigations) { // Paper - Remove unnecessary onTrackingStart during navigation warning
+                if (false && ServerLevel.this.isUpdatingNavigations.get()) { // Paper - Remove unnecessary onTrackingStart during navigation warning // ShreddedPaper - use thread local
                     String s = "onTrackingStart called during navigation iteration";
 
                     Util.logAndPauseIfInIde("onTrackingStart called during navigation iteration", new IllegalStateException("onTrackingStart called during navigation iteration"));
                 }
 
-                ServerLevel.this.navigatingMobs.remove(entityinsentient);
+                chunkSource.tickingRegions.removeNavigationMob(entityinsentient); // ServerLevel.this.navigatingMobs.remove(entityinsentient); // ShreddedPaper
             }
 
             if (entity instanceof EnderDragon entityenderdragon) {
